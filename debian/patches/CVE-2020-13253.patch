Description: CVE-2020-13253
 WP_VIOLATION errors are not modified: the error bit is set, we
 stay in receive-data state, wait for a stop command. All further
 data transfer is ignored. See the check on sd->card_status at the
 beginning of sd_read_data() and sd_write_data().

Author: Abhijith PA <abhijith@debian.org>
Bug-Debian: https://bugs.debian.org/961297

---
Origin: https://git.qemu.org/?p=qemu.git;a=commitdiff;h=790762e5487114341cccc5bffcec4cb3c022c3cd
Last-Update: 2020-09-08

--- qemu-2.8+dfsg.orig/hw/sd/sd.c
+++ qemu-2.8+dfsg/hw/sd/sd.c
@@ -1028,12 +1028,14 @@ static sd_rsp_type_t sd_normal_command(S
     case 17:	/* CMD17:  READ_SINGLE_BLOCK */
         switch (sd->state) {
         case sd_transfer_state:
+            if (addr + sd->blk_len > sd->size) {
+                sd->card_status |= ADDRESS_ERROR;
+                return sd_r1;
+            }
+
             sd->state = sd_sendingdata_state;
             sd->data_start = addr;
             sd->data_offset = 0;
-
-            if (sd->data_start + sd->blk_len > sd->size)
-                sd->card_status |= ADDRESS_ERROR;
             return sd_r1;
 
         default:
@@ -1044,12 +1046,13 @@ static sd_rsp_type_t sd_normal_command(S
     case 18:	/* CMD18:  READ_MULTIPLE_BLOCK */
         switch (sd->state) {
         case sd_transfer_state:
+            if (addr + sd->blk_len > sd->size) {
+                sd->card_status |= ADDRESS_ERROR;
+                return sd_r1;
+            }
             sd->state = sd_sendingdata_state;
             sd->data_start = addr;
             sd->data_offset = 0;
-
-            if (sd->data_start + sd->blk_len > sd->size)
-                sd->card_status |= ADDRESS_ERROR;
             return sd_r1;
 
         default:
@@ -1077,13 +1080,17 @@ static sd_rsp_type_t sd_normal_command(S
             /* Writing in SPI mode not implemented.  */
             if (sd->spi)
                 break;
+
+            if (addr + sd->blk_len > sd->size) {
+                sd->card_status |= ADDRESS_ERROR;
+                return sd_r1;
+            }
+
             sd->state = sd_receivingdata_state;
             sd->data_start = addr;
             sd->data_offset = 0;
             sd->blk_written = 0;
 
-            if (sd->data_start + sd->blk_len > sd->size)
-                sd->card_status |= ADDRESS_ERROR;
             if (sd_wp_addr(sd, sd->data_start))
                 sd->card_status |= WP_VIOLATION;
             if (sd->csd[14] & 0x30)
@@ -1103,13 +1110,17 @@ static sd_rsp_type_t sd_normal_command(S
             /* Writing in SPI mode not implemented.  */
             if (sd->spi)
                 break;
+
+            if (addr + sd->blk_len > sd->size) {
+                sd->card_status |= ADDRESS_ERROR;
+                return sd_r1;
+            }
+
             sd->state = sd_receivingdata_state;
             sd->data_start = addr;
             sd->data_offset = 0;
             sd->blk_written = 0;
 
-            if (sd->data_start + sd->blk_len > sd->size)
-                sd->card_status |= ADDRESS_ERROR;
             if (sd_wp_addr(sd, sd->data_start))
                 sd->card_status |= WP_VIOLATION;
             if (sd->csd[14] & 0x30)
